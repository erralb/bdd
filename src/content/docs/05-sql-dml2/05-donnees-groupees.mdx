---
title: Les regroupements de données
sidebar:
  label: Regroupements
---

import Table from "/src/components/TableSQLite.astro";
import Slide from '/src/components/Slide.astro';

<Slide title="Extraction de données groupées">

Les requêtes examinées jusqu'à maintenant produisent des lignes qui sont généralement une correspondance _une pour une_ avec les lignes d'une table de la clause `FROM`

Nous allons maintenant examiner comment il est possible d'extraire d'une table, ou d'une jointure, des informations sur les _concepts latents_ dans ces tables.

</Slide>
<Slide>

## Le concept

Considérons la table `Clients`. 

On peut y voir, virtuellement du moins, des **groupes de clients** qui ont la même `ville` ou la même `catégorie`.

On pourrait dire que certains clients habitent la même ville, ou appartiennent à la même catégorie.

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Clients"
  showSQL="true"
  query="
SELECT numero, nom, prenom, ville, categorie
FROM Clients;
"
/>

:::tip[&nbsp;]
Le **regroupement de données**, réalisé par la clause `GROUP BY`, permet de mettre en évidence ces groupes et d'extraire des informations sur eux.
:::

</Slide>
<Slide>

## GROUP BY

Par exemple, on souhaite obtenir le nombre de clients _par ville_, ainsi que la valeur moyenne de leur compte.

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Moyennes des clients par ville"
  showSQL="true"
  query="
SELECT 
    ville,
		COUNT(*) AS 'Nombre de clients',
		AVG(compte) AS 'Moyenne des comptes'
FROM Clients
GROUP BY ville ;
"
/>

</Slide>
<Slide>

## HAVING

Des **conditions de sélection** peuvent être imposées aux **groupes sélectionnés**.

Elles sont exprimées dans une clause `HAVING` pour éviter toute confusion avec la clause `WHERE`

Par exemple, si on reprend la requête précédente, on peut ajouter une condition pour ne retenir que les villes avec au moins 3 clients.

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Moyennes des clients par ville qui ont au moins 3 clients"
  showSQL="true"
  query="
SELECT 
    ville,
		COUNT(*) AS 'Nombre de clients',
		AVG(compte) AS 'Moyenne des comptes'
FROM Clients
GROUP BY ville
HAVING COUNT(*) >= 3 ;
"
/>

:::note[Remarque]
La condition exprimée par la clause `HAVING` peut porter sur les éléments cités dans la clause `SELECT`, mais aussi sur toute autre fonction d'agrégation calculable sur chaque groupe.
:::

</Slide>
<Slide>

## Exemples

### Exemple 1

_Donner la liste des clients ayant commandé au moins 2 fois le produit `numéro 1` (le produit numéro 1 est le `T-shirt`)_

Réalisons cette requête par étapes :

1. On sélectionne les lignes de la table `Commandes` en les regroupant par _client_ :

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Commandes regroupées par client"
  showSQL="true"
  query="
SELECT numeroClient , COUNT(*)
FROM Commandes
GROUP BY numeroClient;
"
/>

</Slide>
<Slide title="Exemple 1">

2. On ne retient que les groupes d'un moins 2 commandes :

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Commandes regroupées par client ayant au moins 2 commandes"
  showSQL="true"
  query="
SELECT numeroClient , COUNT(*)
FROM Commandes
GROUP BY numeroClient
HAVING COUNT(*) >= 2;
"
/>

</Slide>
<Slide title="Exemple 1">

3. Finalement, on ne considère, avant groupement, que les commandes spécifiant le produit `numéro 1` :

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Commandes regroupées par client ayant au moins 2 commandes du produit numéro 1"
  showSQL="true"
  query="
SELECT numeroClient , COUNT(*)
FROM Commandes
WHERE numero IN (SELECT numeroCommande FROM Details WHERE numeroProduit = 1 )
GROUP BY numeroClient
HAVING COUNT(*) >= 2;
"
/>

</Slide>
<Slide title="Exemple 1">

4. Pour aller plus loin, on pourrait effectuer une jointure supplémentaire pour sélectionner le produit non pas par son numéro, mais par son nom :

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Commandes regroupées par client ayant au moins 2 commandes du produit T-Shirt"
  showSQL="true"
  query="
SELECT numeroClient, COUNT(*)
FROM Commandes
WHERE numero IN (SELECT numeroCommande FROM Details, Produits P WHERE Details.numeroProduit = P.numero AND P.nom = 'T-shirt' )
GROUP BY numeroClient
HAVING COUNT(*) >= 2;
"
/>

</Slide>
<Slide title="Exemple 1">

#### Syntaxes alternatives

On pourrait aussi formuler cette requête en utilisant des jointures explicites :

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Commandes regroupées par client ayant au moins 2 commandes du produit T-Shirt"
  showSQL="true"
  query="
SELECT P.nom, numeroClient , COUNT(*)
FROM Commandes C, Details D, Produits P
WHERE C.numero = D.numeroCommande 
AND D.numeroProduit = P.numero 
AND P.nom = 'T-shirt'
GROUP BY numeroClient
HAVING COUNT(*) >= 2;
"
/>

</Slide>
<Slide title="Exemple 1">

Et pour terminer, une version avec la syntaxe `JOIN` :

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Commandes regroupées par client ayant au moins 2 commandes du produit T-Shirt"
  showSQL="true"
  query="
SELECT numeroClient , COUNT(*)
FROM Commandes C
JOIN Details D ON C.numero = D.numeroCommande
JOIN Produits P ON D.numeroProduit = P.numero
WHERE P.nom = 'T-shirt'
GROUP BY numeroClient
HAVING COUNT(*) >= 2;
"
/>

</Slide>
<Slide title="Exemple 2">

### Exemple 2

On souhaite obtenir la quantité totale commandée du produit `numéro 1`, toutes commandes confondues :

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Quantité totale commandée du produit numéro 1"
  showSQL="true"
  query="
SELECT numeroProduit, SUM(quantite)
FROM Details
WHERE numeroProduit = 1
GROUP BY numeroProduit;
"
/>

</Slide>
<Slide>

### Exemple 3

Pour chaque client de `Lille`, donner le montant total de ses commandes

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Commandes de Lille"
  showSQL="true"
  query="
SELECT numeroClient, SUM(quantite * prix)
FROM Commandes C, Details D, Produits P, Clients CL
WHERE C.numero = D.numeroCommande
AND D.numeroProduit = P.numero
AND C.numeroClient = CL.numero
AND CL.ville = 'Lille'
GROUP BY numeroClient;
"
/>

</Slide>
<Slide>

### Exemple 4

Donner la quantité qui reste en stock, si on déduit les quantités commandées


<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Quantité restante en stock"
  showSQL="true"
  query={`
SELECT 
  numero, nom,
  stock - ( SELECT SUM(quantite) 
            FROM Details, Produits 
            WHERE numeroProduit = Produits.numero) AS 'Quantité restante'
FROM Produits
GROUP BY numero;
`}
/>

</Slide>
<Slide>

## Multi-colonnes

1. Le critère de groupement peut inclure plusieurs noms de colonne
2. L'ordre des colonnes est indifférent

_Donner pour chaque ville le montant total commandé_

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Montant commandé par ville"
  showSQL="true"
  query="
SELECT ville, SUM(quantite * prix) AS 'montant'
FROM Clients CL, Commandes C, Details D, Produits P
WHERE CL.numero = C.numeroClient
AND C.numero = D.numeroCommande
AND D.numeroProduit = P.numero
GROUP BY ville;
"
/>

_Donner pour chaque ville **et produit** le montant total commandé_

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Montant commandé par ville et produit"
  showSQL="true"
  query="
SELECT ville, P.numero AS 'produit', SUM(quantite * prix) AS 'montant'
FROM Clients CL, Commandes C, Details D, Produits P
WHERE CL.numero = C.numeroClient
AND C.numero = D.numeroCommande
AND D.numeroProduit = P.numero
GROUP BY ville, P.numero;
"
/>

</Slide>
<Slide title="Multi-colonnes">

Syntaxe `JOIN`

```sql
SELECT ville, P.numero AS 'produit', SUM(quantite * prix) AS 'montant'
FROM Clients CL
JOIN Commandes C ON CL.numero = C.numeroClient
JOIN Details D ON C.numero = D.numeroCommande
JOIN Produits P ON D.numeroProduit = P.numero
GROUP BY ville, P.numero;
```

</Slide>
<Slide>

## Calculs

Le critère de groupement peut aussi inclure une expression de calcul quelconque

_Donner la liste des clients en fonction de la première lettre de leur catégorie_

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Clients par catégorie"
  showSQL="true"
  query="
SELECT substr(categorie, 1, 1) AS 'Catégorie', COUNT(*) AS 'Nombre de clients'
FROM Clients
GROUP BY substr(categorie, 1, 1);
"
/>

</Slide>
<Slide>

_Regrouper les clients selon leurs valeurs de COMPTE par intervalle de 1.000_

<Table
  sqliteDB="public/sample/ecommerce/ecommerce-fr-erd-v2.sqlite"
  title="Clients par intervalle de compte"
  showSQL="true"
  query="
SELECT 'de' , abs(compte/1000)*1000 AS MIN, 'à' , abs(compte/1000)*1000 + 999 AS MAX, COUNT(*) AS N
FROM Clients
GROUP BY abs(compte/1000);
"
/>




</Slide>
<Slide>



Syntaxe pour  __SQLite :__

SELECT 'de' ,  __abs__ (COMPTE/1000)*1000 AS MIN,		'a' ,  __abs__ (COMPTE/1000)*1000 + 999 AS MAX,		COUNT(*) AS NFROM CLIENT CGROUP BY  __abs__  (COMPTE/1000) ;



</Slide>
<Slide>



L'extraction de données groupées est à définir avec précaution avec des jointures

Exemple : Donner pour chaque ville, la somme des comptes des clients et le nombre de commandes. On serait tenté d'écrire :

__SELECT__  ville,  __SUM__ (COMPTE) ,  __COUNT__ (*) __FROM__  CLIENT C, COMMANDE M __WHERE__  C.NCLI = M.NCLI __GROUP__   __BY__  ville ;

Ce qui donnerait :

Ce résultat, en apparence correct, est pourtant erroné (indépendamment du fait que les clients sans commande ne sont pas repris)

![](CM4%20-%20Le%20langage%20SQL%20DML%20-%20Les%20Jointures19.png)



</Slide>
<Slide>



![](CM4%20-%20Le%20langage%20SQL%20DML%20-%20Les%20Jointures20.png)

* Le résultat de la jointure n'est pas des clients mais des commandes
  * Rappel : le résultat d'une jointure représente des entités de la table contenant la clé étrangère
* En particulier, le compte du client CS400 est comptabilisé 3 fois, pour un total de 1050 au lieu de 350
* Le calcul de la somme des comptes s'effectue donc sur des ensembles de commandes et non des clients
* Pour répondre correctement à la question il faut procéder en deux étapes



</Slide>
<Slide>



Il est possible d'éviter la clause GROUP BY lorsque le concept latent dans une table est explicitement représenté par une autre table, et que le regroupement ne sert qu'à la sélection

Exemple : Donner les produits dont plus de 500 unités ont été commandées en 2009

__SELECT__  D.NPRO __FROM__  DETAIL D, COMMANDE M __WHERE__  C.NCOM = M.NCOM  __AND__  DATECOM  __LIKE__  '%2009' __GROUP BY__  D.NPRO  __HAVING__   __SUM__ (QCOM) > 500 ;

est équivalente à

__SELECT__  NPRO  __FROM__  PRODUIT P __WHERE__  (  __SELECT__  SUM(QCOM)  __FROM__  DETAIL		 __WHERE__  NPRO = P.NPRO  __AND__  NCOM  __IN__  			( __SELECT__  NCOM  __FROM__  COMMANDE  __WHERE__  DATECOM LIKE ' %2009 ' )

)  __>__  500 ;



</Slide>
